---
title: Rebasing a pushed git branch from its original starting commit onto a commit on another branch
parent: Software Configuration Management
grand_parent: Development Resources
nav_order: 6
---

# Rebasing a pushed git branch from its original starting commit onto a commit on another branch

This is an example of rebasing a git branch from its original parent commit onto some other commit, with a twist that the branch being rebased has already been pushed to a remote.

Take Note

As the [Git FAQ](Git_FAQ) says, don't do this if anyone has pulled your work and based their own work on it!

As with many compound git operations, there's probably more than one way to perform this process. The steps given below are known to have worked in one particular case.

The context for this example is a new feature being required for a customer running a stable version of some UReason product.  The product was built on its own release branch at some point in the past and, since then, many new features have been merged to the **develop** branch.  We don't want to give the customer a new build with all of these recent changes, just one with the new feature that they need.   Ideally we'd simply branch from the release branch on which the stable product build was made, implement the new feature and merge the new feature back into the release branch before making a new build.  However, in this case the work was done on a feature branch created off the **develop** branch.  We can't merge this feature branch into the release branch since that would cause all of the features on the **develop** branch that we *don't* want to also be merged.

Let's say that the product was built on a branch called **release/productX** and that the work for the new feature was done on a branch called **feature/ISSUE-1** that was created by branching from **develop**.  The feature is complete and the branch has been pushed to **origin/feature/ISSUE-1**.  Luckily, no-one has checked out the remote branch to use as the basis for their own work.

The following steps use the git command-line client (version 1.8.5.2 in this particular case) to rebase **feature/ISSUE-1** onto **release/productX**.  The command prompt is **$**; lines that don't start with the command prompt contain output generated by git.

Pre-conditions:

1.  your working copy is clean;
2.  you've pulled all changes from the origin repository.

 

## Step-by-step guide

1.  **1. Check out your local feature branch**

    ```
    $ git checkout feature/ISSUE-1
    Switched to branch 'feature/ISSUE-1'
    Your branch is up-to-date with 'origin/feature/ISSUE-1'.
    ```

2.  **2. Rebase commits from feature/ISSUE-1 made after it branched from develop onto release/productX**

    ```
    $ git rebase --onto release/productX develop feature/ISSUE-1
    First, rewinding head to replay your work on top of it...
    Applying: "The commit message of the first commit on the feature branch"
    ...
    Applying: "The commit message of the last commit on the feature branch" 
    ```

3.  **3. Delete the remote branch**

    ```
    $ git push origin :feature/ISSUE-1
    To http://<user>@stash.ureason.co.uk/scm/urp/urplatform.git 
     - [deleted]         feature/ISSUE-1
    ```

4.  **4. Push the rebased feature branch to the origin repository and set up tracking between local and remote branches**

    ```
    $ git push -u origin feature/ISSUE-1
    Counting objects: 131, done.
    Delta compression using up to 8 threads.
    Compressing objects: 100% (21/21), done.
    Writing objects: 100% (34/34), 5.50 KiB | 0 bytes/s, done.
    Total 34 (delta 20), reused 13 (delta 8)
    To http://<user>@stash.ureason.co.uk/scm/urp/urplatform.git
     * [new branch]      feature/ISSUE-1 -> feature/ISSUE-1
    Branch feature/ISSUE-1 set up to track remote branch feature/ISSUE-1 from origin.
    ```

 

Step 1 may not be needed since it seems the rebase command at step 2 will cause the branch being rebased to be checked out if necessary. This hasn't been verified though.

 

This process depends on the correct invocation of *git rebase*. Simply using *git checkout feature/ISSUE-1* followed by *git rebase release/productX* wouldn't have the desired effect - it would in fact replay all ancestor commits of the feature branch HEAD that don't exist on **release/productX** (*i.e.* in addition to our new feature it would also bring in all of the recent features on **develop** that we don't actually want).

 

Deleting the original remote branch before pushing the rebased feature branch seems to be required. Without this step the local tracking information that still exists between the original local branch and its corresponding remote branch makes git think that changes need to be both pushed and pulled: the push can't be performed until the pull is made, and the pull isn't needed since it affects the original feature branch (which is no longer needed).

## Related articles

**Content by label**
There is no content with the specified labels
